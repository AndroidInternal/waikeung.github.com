<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="X-UA-Compatible" content="chrome=1" />
<meta http-equiv="X-UA-Compatible" content="IE=7" />
<meta name="keywords" content="linux,python,vim,blog,waikeung,waikeungshen,博客,编程,代码,算法,数据结构" />
<meta name="description" content="" />
<link rel="Stylesheet" type="text/css" href="../style.css">
<link rel="Stylesheet" type="text/css" href="../article.css">
<title>algorithm_sort</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<script type="text/javascript" src="scripts/shCore.js"></script>
<script type="text/javascript" src="scripts/shBrushBash.js"></script>
<script type="text/javascript" src="scripts/shBrushCpp.js"></script>
<script type="text/javascript" src="scripts/shBrushCss.js"></script>
<script type="text/javascript" src="scripts/shBrushPython.js"></script>
<script type="text/javascript" src="scripts/shBrushPhp.js"></script>
<script type="text/javascript" src="scripts/shBrushSql.js"></script>
<script type="text/javascript" src="scripts/shBrushJava.js"></script>
<link type="text/css" rel="stylesheet" href="styles/shCore.css"/>
<link type="text/css" rel="stylesheet" href="styles/shThemeDefault.css"/>
<script type="text/javascript">SyntaxHighlighter.all();</script>
</head>
<body>
<div id="header">
    <h1><a href="../index.html">WaikeungShen'Blog</a></h1>
</div>
<div id="article">

<h1 id="toc_1">常用排序算法介绍</h1>
<p>
排序的目标是将一组数据重新排列，排列后的数据符合从小到大(或者从大到小)的次序。
</p>

<p>
这里列出一些常见的排序方法，并用C语言实现它们。
</p>

<p>
一组数据存储为一个数组a中，数组有n个元素。序列最终排列成从小到大的顺序。
</p>

<div class="toc">
<ul>
<li><a href="#toc_1">常用排序算法介绍</a>
<ul>
<li><a href="#toc_1.1">冒泡排序 (Bubble Sort)</a>
<li><a href="#toc_1.2">选择排序 (Selection Sort)</a>
<li><a href="#toc_1.3">插入排序 ( Insertion Sort )</a>
<li><a href="#toc_1.4">希尔排序 (Shell Sort)</a>
</ul>
</ul>
</div>

<h2 id="toc_1.1">冒泡排序 (Bubble Sort)</h2>
<p>
对于一个已经排列好了的序列，它的任意两个相邻的元素，都应该满足 <code>a[i-1] &lt;= a[i]</code>的关系。冒泡排序就是不断的扫描相邻的元素，如果不符合，就将两个元素交换，符合就不交换。经过一次遍历，最大的元素应该处在序列的末尾。
</p>

<ul>
<li>
最差时间复杂度 O(n<sup><small>2</small></sup>)

<li>
最优时间复杂度 O(n)

<li>
平均时间复杂度 O(n<sup><small>2</small></sup>)

</ul>

<pre class="brush:cpp">
void BubbleSort(int a[], int n)
{
    int i, j;
    for (i = 0; i &lt; n - 1; i++)
    {
        for (j = 0; j &lt; n - 1 - i; j++)
            if (a[j - 1] &gt; a[j])
                swap(a + j - 1], a + j);
    }
}
</pre>

<p>
如果某次遍历过程中，未发生交换，这就说明序列都符合要求了，序列已经排序好了，可以中止排序了。修改后的算法如下：
</p>
<pre class="brush:cpp">
void BubbleSort(int a[], int n)
{
    int i, j;
    int sign;
    for (i = 0; i &lt; n - 1; i++)
    {
        sign = 0;
        for (j = 0; j &lt; n - 1 - i; j++)
            if (a[j - 1] &gt; a[j])
            {
                sign = 1;
                swap(a + j - 1, a + j);
            }
        if (sign == 0)
            break;
    }
}
</pre>

<h2 id="toc_1.2">选择排序 (Selection Sort)</h2>
<p>
排序的结果，最小的元素在最左边，第二小的元素在<code>i=1</code>的位置...... 最大的元素在排在最后。
</p>

<p>
选择排序是先找到数组中最小的元素，将它交换到<code>i=0</code>的位置，然后寻找第二小的元素，将它交换到<code>i=1</code>的位置......直到找到第二大的元素，将它交换到<code>n-2</code>的位置。这时，序列以排好。
</p>

<ul>
<li>
最差时间复杂度 O(n<sup><small>2</small></sup>)

<li>
最优时间复杂度 O(n<sup><small>2</small></sup>)

<li>
平均时间复杂度 O(n<sup><small>2</small></sup>)

</ul>

<pre class="brush:cpp">
void selectSort (int a[], int n)
{
    int i, j;
    int min_index;
    for (i = 0; i &lt; n - 1; i++)
    {
        min_index = i;
        for (j = i + 1; j &lt; n; j++)
        {
            if (a[j] &lt; a[min_index])
                min_index = j;
        }
        swap(a + i, a + min_index);
    }
}
</pre>

<h2 id="toc_1.3">插入排序 ( Insertion Sort )</h2>
<p>
基本思想：每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子序列中的适当位置，直到全部记录插入为止。
</p>

<ul>
<li>
最差时间复杂度 O(n<sup><small>2</small></sup>)

<li>
最优时间复杂度 O(n)

<li>
平均时间复杂度 O(n<sup><small>2</small></sup>)

</ul>

<pre class="brush:cpp">
void InsertionSort (int a[], int n)
{
    int i, j;
    int temp;
    for (i = 1; i &lt; n; i++)
    {
        temp = a[i];
        j = i - 1;
        while ((j &gt;= 0) &amp;&amp; (a[j] &gt; temp))
        {
            a[j+1] = a[j];
            j--;
        }
        a[j+1] = temp;
    }
}
</pre>
<p>
改进后的：
</p>
<pre class="brush:cpp">
void InsertionSort (int a[], int n)
{
    int i, j;
    for (i = 1; i &lt; n; i++)
        for (j = i - 1; j &gt;= 0 &amp;&amp; a[j+1] &lt; a[j]; j--)
            swap (a + j + 1, a + j);
}
</pre>

<h2 id="toc_1.4">希尔排序 (Shell Sort)</h2>
<p>
希尔排序是插入排序的一种更高效的改进版本，希尔排序是非稳定排序算法。
</p>

</div>
<div id="footer">
2013-2014 Creat by vimwiki
</div>
</body>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-47865607-1', 'waikeungshen.info');
  ga('send', 'pageview');

</script>
</html>
