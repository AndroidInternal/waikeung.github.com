<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<link rel="Stylesheet" type="text/css" href="../style.css">
<link rel="Stylesheet" type="text/css" href="../head.css">
<title>ssh</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<script type="text/javascript" src="scripts/shCore.js"></script>
<script type="text/javascript" src="scripts/shBrushBash.js"></script>
<script type="text/javascript" src="scripts/shBrushCpp.js"></script>
<script type="text/javascript" src="scripts/shBrushCss.js"></script>
<script type="text/javascript" src="scripts/shBrushPython.js"></script>
<script type="text/javascript" src="scripts/shBrushPhp.js"></script>
<script type="text/javascript" src="scripts/shBrushSql.js"></script>
<script type="text/javascript" src="scripts/shBrushJava.js"></script>
<link type="text/css" rel="stylesheet" href="styles/shCore.css"/>
<link type="text/css" rel="stylesheet" href="styles/shThemeDefault.css"/>
<script type="text/javascript">SyntaxHighlighter.all();</script>
</head>
<body>
<section id="container">
    <section id="masthead">
    <h1 class="title"><a href="../index.html">Waikeung's Blog</a></h1>
    <h2>By <span class="author">waikeung</a></h2>
    <nav>
        <a class="menu" href="../index.html">Home</a>
        <a class="menu" href="../blog/index.html">Archive</a>
        <a class="menu" href="../code.html">Code</a>
        <a class="menu" href="../note.html">Note</a>
        <a class="menu" href="../about.html">About</a>
    </nav>
    </section>

<div id="main">

<h1 id="toc_1">SSH原理及应用</h1>

<p>
由于自己是在用github托管自己的代码，而使用github时需要配置ssh，使自己的主机能够连接到github的服务器上，所以就梳理一下关于ssh的一些知识。
</p>

<p>
SSH是每一台Linux电脑的标准配置。
</p>

<p>
简单说，SSH是一种网络协议，用于计算机之间的加密登录。SSH为一项创建在应用层和传输层基础上的安全协议，为计算机上的Shell（壳层）提供安全的传输和使用环境。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。
</p>

<p>
传统的网络服务程序，如rsh、FTP、POP和Telnet其本质上都是不安全的；因为它们在网络上用明文传送数据、用户帐号和用户口令，很容易受到中间人（man-in-the-middle）攻击方式的攻击。就是存在另一个人或者一台机器冒充真正的服务器接收用户传给服务器的数据，然后再冒充用户把数据传给真正的服务器。
</p>

<p>
而SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理过程中的信息泄露问题。通过SSH可以对所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。SSH之另一项优点为其传输的数据可以是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、POP、甚至为PPP提供一个安全的“通道”。
</p>

<p>
1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。
</p>

<p>
在介绍ssh的原理之前，先要了解下密钥的问题。
</p>

<h2 id="toc_1.1">密钥</h2>
<p>
公开密钥加密也称为非对称(密钥)加密,该思想最早由雷夫·莫寇（Ralph C. Merkle）在1974年提出，之后在1976年。狄菲（Whitfield Diffie）与赫尔曼（Martin Hellman）两位学者以单向函数与单向暗门函数为基础，为发讯与收讯的两方创建密钥。
</p>

<p>
非对称密钥，是指一对加密密钥与解密密钥，这两个密钥是数学相关，用某用户密钥加密后所得的信息，只能用该用户的解密密钥才能解密。如果知道了其中一个，并不能计算出另外一个。因此如果公开了一对密钥中的一个，并不会危害到另外一个的秘密性质。称公开的密钥为公钥；不公开的密钥为私钥。
</p>

<ul>
<li>
如果加密密钥是公开的，这用于客户给私钥所有者上传加密的数据，这被称作为公开密钥加密(狭义)。
<br />        例如，网络银行的客户发给银行网站的账户操作的加密数据。

<li>
如果解密密钥是公开的，用私钥加密的信息，可以用公钥对其解密，用于客户验证持有私钥一方发布的数据或文件是完整准确的，接收者由此可知这条信息确实来自于拥有私钥的某人，这被称作数字签名，公钥的形式就是数字证书。
<br />        例如，从网上下载的安装程序，一般都带有程序制作者的数字签名，可以证明该程序的确是该作者（公司）发布的而不是第三方伪造的且未被篡改过(身份认证/验证)。

</ul>

<p>
非对称加密的优点在于，与对称密钥加密相比，优点在于无需共享的通用密钥，解密的私钥不发往任何用户。即使公钥在网上被截获，如果没有与其匹配的私钥，也无法解密，所截获的公钥是没有任何用处的。
</p>

<h2 id="toc_1.2">中间人攻击</h2>
<p>
在密码学和计算机安全领域中，中间人攻击是指攻击者与通讯的两端分别建立独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。
</p>

<p>
一个中间人攻击能成功的前提条件是攻击者能将自己伪装成每一个参与会话的终端，并且不被其他终端识破。中间人攻击是一个缺乏相互认证的攻击。大多数的加密协议都专门加入了一些特殊的认证方法以阻止中间人攻击。例如，SSL协议可以验证参与通讯的一方或双方使用的证书是否是由权威的受信任的数字证书认证机构颁发，并且能执行双向身份认证。
</p>

<h3 id="toc_1.2.1">攻击示例</h3>
<p>
假设A与B直接要相互进行通讯。首先A向B索取B的公钥，B将公钥发给A，A用B的公钥将消息加密后发给B，B利用自己的私钥解密。
</p>
<pre>
    A		 “给我你的公钥” ------&gt;				     B
	A  		  &lt;------------“B的公钥” 			   	 B
	A 		“消息”------[利用B的公钥加密]---&gt;		 B
</pre>
<p>
B利用自己的私钥解密的到消息
</p>

<p>
这样的通讯看似很安全，倘若这是时候出现了一个C，希望拦截通讯并窃听，有必要的话传递一个虚假消息。
</p>

<p>
首先A向B索取B的公钥，B将公钥发给A，就在这时，C拦截了B发给A的公钥，这时一个中间人攻击就展开了。C向A发消息，并附上C自己的公钥，并生成自己是B。A收到后以为是B的公钥（其实是C的公钥），用此公钥进行加密后发给B。C拦截了这条消息，并用自己的私钥进行了解密。若C想完全可以对这条消息进行修改，然后用B的公钥加密后发送给B。当B收到这条消息时会认为是A发送的。
</p>
<pre>
    A 	“给我你的公钥” ---&gt;		  C 								B
    A 							  C 	“给我你的公钥”----&gt;   		B
    A 							  C   &lt;------“B的公钥”				B
    A 	&lt;-----”C的公钥”			  C 								B
    A 	“消息”---[C的公钥加密]--&gt; C								    B
    A 							  C	 “虚假消息”--[B的公钥加密]--&gt;   B
</pre>
<p>
这例子说明A和B需要某种方式确定他们真正拿得是对方的密钥，而不是中间人C的密钥。在原理上，可以针对任何使用公钥——密钥技术的通讯消息发起攻击。幸运的是，有各种不同的技术可以帮助抵御MITM攻击。
</p>

<p>
B给A的回信可以采用“数字签名”的方式保证回信的完整。但还是不能抵御中间人的攻击。所以就有了“数字证书”。B去“数字中心”（简称CA），为自己的公钥做认证。数字中心用自己的私钥对B的公钥及一些信息进行加密，生成“数字证书”。这样B给A写信时签名的同时附上数字证书。A收信后用数字中心给的公钥解开数字证书，就能拿到真正的B的公钥了,就能证明数字签名是不是B签的。
</p>

<p>
了解了公钥及数字证书，现在来看SSH。
</p>

<p>
SSH之所以能够保证安全	，原因在于它采用公钥加密。
</p>

<p>
整个过程是这样的：
</p>

<ol>
<li>
远程主机收到用户的登录请求，把自己的公钥发给用户。

<li>
用户使用这个公钥，将登录密码加密后，发送回来。

<li>
远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。

</ol>

<p>
这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。
</p>

<p>
可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的"中间人攻击"（Man-in-the-middle attack）。
</p>

<h2 id="toc_1.3">SSH协议是如何应对的呢？</h2>
<p>
在客户端来看，SSH提供两种级别的安全验证。
</p>

<ul>
<li>
第一种级别（基于密码的安全验证），知道帐号和密码，就可以登录到远程主机，并且所有传输的数据都会被加密。但是，可能会有别的服务器在冒充真正的服务器，无法避免被“中间人”攻击。

<li>
第二种级别（基于密钥的安全验证），需要依靠密钥，也就是你必须为自己创建一对密钥，并把公有密钥放在需要访问的服务器上。客户端软件会向服务器发出请求，请求用你的密钥进行安全验证。服务器收到请求之后，先在你在该服务器的用户根目录下寻找你的公有密钥，然后把它和你发送过来的公有密钥进行比较。如果两个密钥一致，服务器就用公有密钥加密“质询”并把它发送给客户端软件。从而避免被“中间人”攻击。

</ul>

<p>
在服务器端，SSH也提供安全验证。 
</p>

<ul>
<li>
在第一种方案中，主机将自己的公用密钥分发给相关的客户端，客户端在访问主机时则使用该主机的公开密钥来加密数据，主机则使用自己的私有密钥来解密数据，从而实现主机密钥认证，确定客户端的可靠身份。 

<li>
在第二种方案中，存在一个密钥认证中心，所有提供服务的主机都将自己的公开密钥提交给认证中心，而任何作为客户端的主机则只要保存一份认证中心的公开密钥就可以了。在这种模式下，客户端必须访问认证中心然后才能访问服务器主机。

</ul>

<p>
如果你是第一次登录对方主机，系统会出现下面的提示：
</p>
<pre>
    $ ssh user@host 
    The authenticity of host 'host (12.18.429.21)' can't be established. 
    RSA key fingerprint is 
    98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d. 
    Are you sure you want to continue connecting (yes/no)? 
</pre>
<p>
这段话的意思是，无法确定host主机的真实性，只知道它的公钥指纹，问你还想局需连接吗？
</p>

<p>
所谓"公钥指纹",是指公钥长度较长(这里采用RSA算法,长达1024位),很难比对, 所以对其进行MD5计算,将它变成一个128位的指纹。上例中就是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d,再进行比较,就容易多了。
</p>

<p>
假定经过风险衡量以后,用户决定接受这个远程主机的公钥。
</p>
<pre>
    Are you sure you want to continue connecting (yes/no)? yes
</pre>
<p>
系统会出现一句提示,表示host主机已经得到认可。
</p>
<pre>
    Warning: Permanently added 'host,12.18.429.21' 
    (RSA) to the list of known hosts. 
</pre>
<p>
然后,会要求输入密码。
</p>
<pre>
    Password: (enter password) 
</pre>
<p>
如果密码正确,就可以登录了。 
</p>

<p>
当远程主机的公钥被接受以后,它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机,系统就会认出它的公钥已经保存在本地了,从而跳过警告部分,直 接提示输入密码。 
</p>

<p>
每个SSH用户都有自己的known_hosts文件,此外系统也有一个这样的文件,通常 是/etc/ssh/ssh_known_hosts,保存一些对所有用户都可信赖的远程主机的公钥。
</p>

<p>
使用密码登录,每次都必须输入密码,非常麻烦。好在SSH还提供了公钥登录,可以省去输入密码的步骤。 
</p>

<p>
所谓"公钥登录",原理很简单,就是用户将自己的公钥储存在远程主机上。登录的时候,远程主机会向用户发送一段随机字符串,用户用自己的私钥加密后,再发回来。远程主机用事先储存的公钥进行解密,如果成功,就证明用户是可信的,直接允许登录shell,不再要求密码。
</p>

<p>
就像我的托管我代码的github网站，git推送本地仓库代码时也是需要登录到github的远程服务器的，但我并不需要每次都输入密码，就是应用我把我的公钥保存在github的主机上，每次都用公钥登录的。 
</p>

</div>
<div id="footer">
2013-2014 Creat by vimwiki
</div>
</section>
</body>
</html>
